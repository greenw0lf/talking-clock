# -*- coding: utf-8 -*-
"""Polishmain().ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KdmenPckUdfKc6oOCjmdg8Pfi8rK00I8
"""

from scipy.io import wavfile
import numpy as np
import time

def cut_silence(signal,sr=16000,threshold=0.09,padding=40): #added an extra sr parameter
   max_signal=max(signal) #max amplitude
   _threshold=threshold*max_signal #determine the threshold as %age of max amplitude
   len_padding=(padding/1000)*sr #based on the sampling rate, we determine the length of the padding (converted to seconds)
   cutoff=np.where(signal>_threshold) #indices of our beginning and end stage.
   _cutoff=cutoff[0] #extract the actual array
   first_cutoff=int(_cutoff[0]-len_padding) #take the first element and go back by the amount of samples stipulated in the padding
   last_cutoff=int(_cutoff[-1]+len_padding) #take the last element and go forwards by the amount of samples stipulated in the padding
   if first_cutoff<0:
     first_cutoff=0 #in case someone passes a padding which is too large, to avoid negative indices
   if last_cutoff>len(signal):
     last_cutoff=len(signal) #incase someone passes a padding which is too large, to avoid going out of range of array
   _signal=signal[first_cutoff:last_cutoff] #trim our signal according to our calculated endpoints
   signal =_signal
   return(signal)

def read_audio(filename: str):
    sr, audio = wavfile.read(r"./PolishAudio+Logic/" + filename) #replace dir as appropriate
    audio=cut_silence(audio)
    return audio


def get_sr(filename: str):
    sr, audio = wavfile.read(r"./PolishAudio+Logic/" + filename) #replace dir as appropriate
    return sr


def get_current_time():
    current_time = time.strftime('%H:%M')
    split_time = current_time.split(':')
    return int(split_time[0]), int(split_time[1])


def get_hour_filename(hr: int, m: int):
    if m >= 30: #Poland has 30-60 as (x to)
        hr += 1
    if hr == 0 and m == 0:
      return 'Midnight.wav' #midnight -polnoc
    elif hr == 0 and m >0:
      return 'Past_Midnight.wav' #past midnight has grammar - polnoc(y) 
    else:
      if m== 0 or m >30:
        return str(hr) + 'tha.wav' #non possessive
      else:
        return str(hr) + 'th.wav' #possessive


def get_minute_filename(m: int):
    if m == 0:
        pass
    elif m > 30:
      m = 60 - m
      return str(m) + 'POL.wav'
    elif m ==30:
      return 'half_to.wav'
    else:
      return str(m) + 'POL.wav'


def with_or_without(m: int):
    return 'to.wav' if m >= 30 else 'and.wav'


def concatenate_audio(filenames):
    audio = []
    sr = get_sr(filenames[0])
    for name in filenames:
        audio = np.concatenate((audio, read_audio(name)))
    return sr, audio


def speak_the_clock():
    hour, minute = get_current_time()
    print("The time is " + str(hour) + ':' + str(minute))
    audio_names = ['Its.wav']
    if minute != 0:
      if minute < 30:
        audio_names.append(get_minute_filename(minute))
        audio_names.append(with_or_without(minute))
      elif minute >30:
        audio_names.append(with_or_without(minute))
        audio_names.append(get_minute_filename(minute))
      else:
        audio_names.append(get_minute_filename(minute))
    audio_names.append(get_hour_filename(hour, minute))

    sr, result_audio = concatenate_audio(audio_names)
    result_audio = np.array(result_audio, dtype=np.int16)

    wavfile.write('result.wav', sr, result_audio)
    return 'result.wav'
audio=speak_the_clock()
from scipy.io.wavfile import read, write
from IPython.display import Audio
sr, audio = read(audio)
Audio(audio,rate=sr)