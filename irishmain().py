# -*- coding: utf-8 -*-
"""Irishmain().ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pnL2gaci9Hsr246hBkh8TdSGOQUFYZxE
"""

from scipy.io import wavfile
from playsound import playsound #unused here, replace as appropriate
import numpy as np
import time


def cut_silence(signal,sr=16000,threshold=0.05,padding=150,output='output.wav'): #added an extra sr parameter
   max_signal=max(signal) #max amplitude
   _threshold=threshold*max_signal #determine the threshold as %age of max amplitude
   len_padding=(padding/1000)*sr #based on the sampling rate, we determine the length of the padding (converted to seconds)
   cutoff=np.where(signal>_threshold) #indices of our beginning and end stage.
   _cutoff=cutoff[0] #extract the actual array
   first_cutoff=int(_cutoff[0]-len_padding) #take the first element and go back by the amount of samples stipulated in the padding
   last_cutoff=int(_cutoff[-1]+len_padding) #take the last element and go forwards by the amount of samples stipulated in the padding
   if first_cutoff<0:
     first_cutoff=0 #in case someone passes a padding which is too large, to avoid negative indices
   if last_cutoff>len(signal):
     last_cutoff=len(signal) #incase someone passes a padding which is too large, to avoid going out of range of array
   _signal=signal[first_cutoff:last_cutoff] #trim our signal according to our calculated endpoints
   signal =_signal
   return(signal)

def read_audio(filename: str):
    sr, audio = wavfile.read(r"./IrishAudio+Logic/" + filename) #replace dir as appropriate
    audio=cut_silence(audio)
    return audio


def get_sr(filename: str):
    sr, audio = wavfile.read(r"./IrishAudio+Logic/" + filename) #replace dir as appropriate
    return sr


def get_current_time():
    current_time = time.strftime('%H:%M')
    split_time = current_time.split(':')
    return int(split_time[0]), int(split_time[1])


def get_hour_filename(hr: int, m: int):
    if m > 30:
        hr += 1
    if hr == 0:
      return 'Midnight.wav'
    else:
      if hr >=12:
        hr = hr-12
        return str(hr) + 'IRI.wav'
      else:
        return str(hr) + 'IRI.wav'


def get_minute_filename(m: int):
    if m == 0:
        return 'oclock.wav'
    elif m == 15 or m == 45:
        return '15IRI.wav'
    elif m > 30:
        m = 60 - m
    return str(m) + 'IRI.wav'


def with_or_without(m: int):
    return 'to.wav' if m > 30 else 'past.wav'


def concatenate_audio(filenames):
    audio = []
    sr = get_sr(filenames[0])
    for name in filenames:
        audio = np.concatenate((audio, read_audio(name)))
    return sr, audio


def speak_the_clock():
    am=2
    hour, minute = get_current_time()
    if hour >=12:
      am=0
    else:
      am=1
    print("The time is " + str(hour) + ':' + str(minute))
    audio_names = ['Its.wav']
    if minute != 0:
        audio_names.append(get_minute_filename(minute))
        audio_names.append(with_or_without(minute))
        audio_names.append(get_hour_filename(hour, minute))
    else:
        audio_names.append(get_hour_filename(hour, minute))
        audio_names.append(get_minute_filename(minute))
      
    if hour !=0:
      if am==1:
        audio_names.append('am.wav')
      elif am==0:
        audio_names.append('pm.wav')
      else:
        print("Error, failed am/pm conversion")

    sr, result_audio = concatenate_audio(audio_names)
    result_audio = np.array(result_audio, dtype=np.int16)

    wavfile.write('result.wav', sr, result_audio)
    return 'result.wav'
audio=speak_the_clock()
from scipy.io.wavfile import read, write
from IPython.display import Audio
sr, audio = read(audio)
Audio(audio,rate=sr)